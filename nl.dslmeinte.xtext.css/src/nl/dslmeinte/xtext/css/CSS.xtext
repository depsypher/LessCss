/**
 * Grammar for CSS3 - by Meinte Boersma (http://www.dslconsultancy.com/, http://dslmeinte.wordpress.com/).
 * 
 * The specification of the CSS3 language can be found from: http://www.w3.org/TR/CSS/
 * 
 * This implementation does not completely comply with the W3C specification, since
 * it's a work-in-progress. Notable global aspects that are missing:
 * 	- case-insensitivity
 * 	- complete compliance with respect to lexical scanning (tokenization)
 * It is my intention to generate this grammar partially from a CSS definition.
 */


grammar nl.dslmeinte.xtext.css.CSS hidden(WS, ML_COMMENT)

generate css "http://www.dslmeinte.nl/xtext/css"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


CSSFile:
	statements+=Statement*
	;

Statement:
	Import | NamespaceDeclaration | RuleSet
	;

Import:
	'@import' importURI=STRING
	;

NamespaceDeclaration:
	'@namespace' name=ID? url=URL ';'
	;

RuleSet:
	selectors+=Selector (',' selectors+=Selector)* '{'	// ~ selectors_group
		(
			propertyValues+=PropertyValue (';' propertyValues+=PropertyValue)* ';'?
		)?
	'}'
	;
	/*
	 * Note that this grammar is a little wider than the specification allows,
	 * since whitespace following a SelectorExpression is hidden.
	 */

PropertyValue:
	KnownPropertyValue | UnknownPropertyValue
	;

KnownPropertyValue:
	name=KnownProperties ':' values+=ValueLiteral+
	;

UnknownPropertyValue:
	name=ID ':' values+=ValueLiteral+
	;

enum KnownProperties:
	color | border_top='border-top' // | ..
	;
	// TODO  generate into this grammar from other DSL...


/*
 * +-----------+
 * | Selectors |
 * +-----------+
 * 
 * Specification: http://www.w3.org/TR/css3-selectors
 */

Selector:
	CombinatorExpression
	;

SimpleSelectorSequence hidden():
	  ( head=( TypeSelector | UniversalSelector ) simpleSelectors+=( IDSelector | AttributeSelector | ClassSelector | PseudoSelector | NegationSelector )* )
	| (                                           simpleSelectors+=( IDSelector | AttributeSelector | ClassSelector | PseudoSelector | NegationSelector )+ )
	;
	// TODO  modify Ecore s.t. head and simpleSelectors are of type SimpleSelector (==only occurrence of that)

CombinatorExpression returns SelectorExpression hidden():
	SimpleSelectorSequence (
		  {DescendantCombinator.left=current}		wsI=WS					right=SimpleSelectorSequence
		| {ChildCombinator.left=current}			wsL=WS? '>' wsR=WS?		right=SimpleSelectorSequence
		| {AdjacentSiblingCombinator.left=current}	wsL=WS? '+' wsR=WS?		right=SimpleSelectorSequence
		| {GeneralSiblingCombinator.left=current}	wsL=WS? '~' wsR=WS?		right=SimpleSelectorSequence
	)*
	;
	/*
	 * The parse tree from a CombinatorExpression will always yield a linked list
	 * (maximally-unbalanced, right-sided tree), but this way it's easier to
	 * assign the specific combinator and surrounding whitespace so that the object
	 * is re-serializable.
	 */

enum NoArgsPseudos:
	  link | visited
	| hover | active | focus
	| target
	| enabled | disabled | checked | indeterminate
	| root
	| firstChild='first-child' | lastChild='last-child'
    | onlyChild='only-child'
    | empty
	;

SimpleSelector:
	  TypeSelector
	| UniversalSelector
	| AttributeSelector
	| IDSelector
	| ClassSelector
	| ParentCombinator
	;

TypeSelector:
	(namespacePrefix=NamespacePrefix)? ( knownType=HtmlElements | unknownType=ID )
	;

NamespacePrefix:
	  ( {NamespacePrefix} namespace=[NamespaceDeclaration|ID] | {UniversalNamespacePrefix} '*' ) '|'
	| {WithoutNamespacePrefix} '|'
	;

enum HtmlElements:
	a | pre | body
	;
	// TODO  generate into this grammar from other DSL...

UniversalSelector:
	{UniversalSelector}
	(namespacePrefix=NamespacePrefix)? '*'
	;

AttributeSelector hidden(WS):
	'['
		attribute=Attribute matcher=AttributeSelectorMatchers value=(ID|STRING)
	']'
	;

Attribute hidden():
	(namespacePrefix=NamespacePrefix)? name=ID
	;

enum AttributeSelectorMatchers:
	  prefix='^='
	| suffix='$='
	| substring='*='
	| exact='='		// TODO  check name
	| includes='~='
	| language='|='	// TODO  check name
	;

IDSelector:
	name=HASH_ID
	;

ClassSelector:
	name=DOT_ID
	;

PseudoSelector:
	  NoArgsPseudoClassSelector
	| PseudoElementSelector
	| LanguagePseudoClassSelector
	| FunctionalPseudoClassSelector
	;

NoArgsPseudoClassSelector hidden():
	':' pseudo=NoArgsPseudos
	;

PseudoElementSelector hidden():
	':' doubleSemiColon?=':'? pseudo=PseudoElements
	;

enum PseudoElements:
	  firstLetter='first-letter' | firstLine='first-line'
	| before | after
	;

FunctionalPseudoClassSelector hidden():
	':' pseudo=FunctionalPseudoClasses '(' argument=TypeArgument ')'
	;

TypeArgument hidden(WS):
	  ConstantArgument
	| LinearArgument
	| {ParityArgument} parity=Parities
	;

LinearArgument hidden(WS):
	coefficient=Coefficient ( constantSign=('-'|'+')? constant=INT )?
	;

Coefficient hidden():
	{Coefficient}
	sign=('-'|'+')? int=INT? 'n'
	;

ConstantArgument hidden():	// separate rule to control whitespace
	sign=('-'|'+')? int=INT
	;

enum Parities:
	odd | even
	;

enum FunctionalPseudoClasses:
	  nthChild='nth-child' | nthLastChild='nth-last-child'
	| nthOfType='nth-of-type' | nthLastOfType='nth-last-if-type'
	| firstOfType='first-of-type' | lastOfType='last-of-type'
	| onlyOfType='only-of-type'
	;

LanguagePseudoClassSelector hidden():
	':lang(' langugage=ID ')'
	;
	// validation: language matches /\w+(-\w+)?/

NegationSelector hidden():
	':not(' simpleSelector=SimpleSelector ')'
	;
	// validation: simpleSelector cannot be a NegationSelector nor a ParentCombinator

ParentCombinator:	// used in Less grammar (needs validation for when used in CSS file!)
	{ParentCombinator} '&'
	;


/*
 * +---------------------+
 * | CSS property values |
 * +---------------------+
 */

ValueLiteral:
	NumberLiteral | StringLiteral | ColorLiteral | BareWordLiteral
	;

NumberLiteral:
	( {IntegerLiteral} int=INT | {DecimalLiteral} decimal=DECIMAL )
	dimension=Dimensions?
	;

enum Dimensions:
	in | cm | mm | pt | pc | em | ex | px | perc='%'
	;

StringLiteral:
	value=STRING
	;

ColorLiteral:
	  {RGBColor} rgb=RGB_COLOR
	| {NamedColor} color=ColorNames
	| ComponentColorLiteral
	;

ComponentColorLiteral:
	  {ComponentRGBColor} 'rgb' '(' red=NumberLiteral ',' green=NumberLiteral ',' blue=NumberLiteral ')'
	| {ComponentHSLColor} 'hsl' '(' hue=NumberLiteral ',' saturation=NumberLiteral ',' lightness=NumberLiteral ')'
	;
	// validation on ComponentRGBColor:
	//	either all percentages (with correct range), or all dimension-less integers 0-255

enum ColorNames:
	black | white // | ...
	;
	// TODO  generate into this grammar from other DSL

// something we don't know about:
BareWordLiteral:
	bareWord=ID
	;


/*
 * +-----------+
 * | Terminals |
 * +-----------+
 */

terminal RGB_COLOR: '#' HEX_DIGIT+ ;
	// validation: exactly 3 or 6 hex-digits
	// CSSValueConverterService#RGB_COLOR takes care of removing the '#' and validation
	/*
	 * Note that this terminal rule must come before the HASH_ID one,
	 * since the latter subsumes the first.
	 */

// re-definition of ID to allow hyphens:
terminal ID: ID_START ID_PART* ;

// special terminal for ID..euhmm..id's:
terminal HASH_ID: '#' PREFIXABLE_ID_START ID_PART* ;
	// CSSValueConverterService#HASH_ID takes care of removing the '#'

// special terminal for class references:
terminal DOT_ID: '.' PREFIXABLE_ID_START ID_PART* ;
	// CSSValueConverterService#DOT_ID takes care of removing the '.'

// special terminal for namespace references:
terminal PIPE_ID: '|' PREFIXABLE_ID_START ID_PART* ;

terminal URL: 'url(' -> ')' ;
	// CSSValueConverterService#URL takes care of removing the 'url(' WS .. WS ')

terminal INT returns ecore::EInt: ('-')? DEC_DIGIT+ ;

terminal DECIMAL returns ecore::EDouble: ('-')? DEC_DIGIT+ '.' DEC_DIGIT+ ;

terminal fragment HEX_DIGIT: '0'..'9' | 'a'..'f' | 'A'..'F' ;

terminal fragment DEC_DIGIT: '0'..'9' ;

terminal fragment ID_PART: ('a'..'z'|'A'..'Z'|'_'|'-'|'0'..'9') ;

terminal fragment ID_START: PREFIXABLE_ID_START | '-';

terminal fragment PREFIXABLE_ID_START: ('a'..'z'|'A'..'Z'|'_') ;

terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		;

terminal ML_COMMENT	: '/*' -> '*/' ;

terminal WS			: (' '|'\t'|'\r'|'\n')+ ;	// TODO  add '\f' without causing Xtext generation problems

