grammar nl.dslmeinte.xtext.css.CSS with org.eclipse.xtext.common.Terminals hidden(WS, ML_COMMENT)

generate css "http://www.dslmeinte.nl/xtext/css"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


/**
 * Grammar for CSS3 - to be generated partially from a CSS Definition.
 * 
 * The specification of the CSS3 language can be found from: http://www.w3.org/TR/CSS/
 * 
 * This implementation does not completely comply with the W3C specification, since
 * it's a work-in-progress. Notable global aspects that are missing:
 * 	- case-insensitivity
 * 	- complete compliance with respect to lexical scanning (tokenization)
 */

CSSFile:
	statements+=Statement*
	;

Statement:
	Import | Rule
	;

Import:
	'@import' importURI=STRING
	;

Rule:
	selectors+=SelectorExpression (',' selectors+=SelectorExpression)* '{'
		(
			propertyValues+=PropertyValue (';' propertyValues+=PropertyValue)* ';'?
		)?
	'}'
	;

PropertyValue:
	KnownPropertyValue | UnknownPropertyValue
	;

KnownPropertyValue:
	name=KnownProperties ':' values+=ValueLiteral+
	;

UnknownPropertyValue:
	name=ID ':' values+=ValueLiteral+
	;

enum KnownProperties:
	color | border_top='border-top' // | ..
	;
	// TODO  generate into this grammar from other DSL...


/*
 * +----------------------+
 * | Selector expressions |
 * +----------------------+
 * 
 * Specification: http://www.w3.org/TR/css3-selectors
 * Note that this implementation is not yet complete!
 * 
 * From high to low precedence:
 * 
 * - universal, type, ID, class: atomic (primary)
 * - ID, class: postfix, left-associative
 * - attribute selectors: simple, value (5 variants), language; postfix, left-associative
 * - pseudo-class: postfix, non-associative
 * - child, adjacent sibling, descendant: infix/binary, left-associative
 */

SelectorExpression:
	CombinatorExpression
	;

CombinatorExpression returns SelectorExpression hidden():
	PseudoClassExpression (
		  {DescendantCombinator.left=current}		ws=WS					right=PseudoClassExpression
		| {ChildCombinator.left=current}			wsL=WS? '>' wsR=WS?		right=PseudoClassExpression
		| {AdjacentSiblingCombinator.left=current}	wsL=WS? '+' wsR=WS?		right=PseudoClassExpression
		| {GeneralSiblingCombinator.left=current}	wsL=WS? '~' wsR=WS?		right=PseudoClassExpression
	)*
	;
	// The scanned whitespace needs to be assigned, otherwise we can't re-serialize reliably.

PseudoClassExpression returns SelectorExpression hidden():
	AttributeSelectorExpression ({PseudoClassSelector.operand=current} ':' pseudoClass=PseudoClasses)?
	;

enum PseudoClasses:
	  active | after | before
	| firstChild='first-child' | firstLetter='first-letter' | firstLine='first-line'
	| focus | hover | lang | link | visited
	;

AttributeSelectorExpression returns SelectorExpression hidden():
	SubSelectorExpression (
		'['
			(
				  {SimpleAttributeSelector.operand=current}		attributeName=ID
				| {AttributeValueSelector.operand=current}		attributeName=ID operator=AttributeValueComparators value=STRING
				| {LanguageAttributeSelector.operand=current}	attributeName=ID '|=' languageName=STRING 
			)
		 ']'
	)*
	;

enum AttributeValueComparators:
	  exact='='
	| partial='~='
	| beginningSubstring='^='
	| endingSubstring='$='
	| arbitrarySubstring='*='
	;

SubSelectorExpression returns SelectorExpression hidden():
	PrimarySelectorExpression (
		  {IDSubSelector.parent=current}	name=HASH_ID
		| {ClassSubSelector.parent=current}	name=DOT_ID
	)*
	;

PrimarySelectorExpression returns SelectorExpression:
	SimpleSelector
	;

SimpleSelector:
	  {UniversalSelector} '*'
	| {TypeSelector}	( knownType=HtmlElements | unknownType=ID )
	| {IDSelector}		name=HASH_ID
	| {ClassSelector}	name=DOT_ID
	;

enum HtmlElements:
	a | pre | body
	;
	// TODO  generate into this grammar from other DSL...


/*
 * +---------------------+
 * | CSS property values |
 * +---------------------+
 */

ValueLiteral:
	NumberLiteral | StringLiteral | ColorLiteral | BareWordLiteral
	;

NumberLiteral hidden():
	(int=INT | decimal=DECIMAL) dimension=Dimensions?
	;

enum Dimensions:
	in | cm | mm | pt | pc | em | ex | px | perc='%'
	;

StringLiteral:
	value=STRING
	;

ColorLiteral:
	  {RGBColor} rgb=RGB_COLOR
	| {NamedColor} color=ColorNames
	| ComponentColorLiteral
	;

ComponentColorLiteral:
	  {ComponentRGBColor} 'rgb' '(' red=NumberLiteral ',' green=NumberLiteral ',' blue=NumberLiteral ')'
	| {ComponentHSLColor} 'hsl' '(' hue=NumberLiteral ',' saturation=NumberLiteral ',' lightness=NumberLiteral ')'
	;
	// validation on ComponentRGBColor:
	//	either all percentages (with correct range), or all dimension-less integers 0-255

enum ColorNames:
	black | white // | ...
	;
	// TODO  generate into this grammar from other DSL

// something we don't know about:
BareWordLiteral:
	bareWord=ID
	;

// TODO  UriLiteral


/*
 * +-----------+
 * | Terminals |
 * +-----------+
 */

terminal RGB_COLOR: '#' HEX_DIGIT+ ;
	// validation: exactly 3 or 6 hex-digits
	// CSSValueConverterService#RGB_COLOR takes care of removing the '#' and validation
	/*
	 * Note that this terminal rule must come before the HASH_ID one,
	 * since the latter subsumes the first.
	 */

// re-definition of ID to allow hyphens:
terminal ID: ID_START ID_PART* ;

// special terminal for ID..euhmm..id's:
terminal HASH_ID: '#' PREFIXED_ID_START ID_PART* ;
	// CSSValueConverterService#HASH_ID takes care of removing the '#'

// special terminal for class id's:
terminal DOT_ID: '.' PREFIXED_ID_START ID_PART* ;
	// CSSValueConverterService#DOT_ID takes care of removing the '.'

terminal INT returns ecore::EInt: ('-')? DEC_DIGIT+ ;

terminal DECIMAL returns ecore::EDouble: ('-')? DEC_DIGIT+ '.' DEC_DIGIT+ ;

terminal fragment HEX_DIGIT: '0'..'9' | 'a'..'f' | 'A'..'F' ;

terminal fragment DEC_DIGIT: '0'..'9' ;

terminal fragment ID_PART: ('a'..'z'|'A'..'Z'|'_'|'-'|'0'..'9') ;

terminal fragment ID_START: PREFIXED_ID_START | '-';

terminal fragment PREFIXED_ID_START: ('a'..'z'|'A'..'Z'|'_') ;

