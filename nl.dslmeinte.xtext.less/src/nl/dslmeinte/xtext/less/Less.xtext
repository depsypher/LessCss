grammar nl.dslmeinte.xtext.less.Less with nl.dslmeinte.xtext.css.CSS hidden(WS, SL_COMMENT)

import "http://www.dslmeinte.nl/xtext/css" as css

generate less "http://www.dslmeinte.nl/xtext/less"


LessFile:
	( '@charset' charSet=STRING ';' )?
	imports+=ImportDeclaration*
	statements+=LessStatement*
	;

LessStatement:
	  (VariableDefinition ';')
	| ExtendedRuleSet
	| VisibleComment
	| {LessOtherTopLevelDeclaration} declaration=CSSOtherTopLevelDeclaration	// TODO  getting rid of the extra indirection would be nice...
	;

VariableDefinition:
	name=VariableDeclaration ':' valuesLists=PropertyExpressionsLists
	;

VariableDeclaration:
	name=AT_ID
	;

VisibleComment:
	comment=ML_COMMENT
	;

	// TODO  tweak ImportUriGlobalScopeProvider to check on the importURI's extension and behave accordingly
	// TODO  make compatible with CSS def.


/*
 * +-----------+
 * | Rule sets |
 * +-----------+
 */

ExtendedRuleSet hidden(WS, SL_COMMENT, ML_COMMENT):		// ML_COMMENT hidden means that inline comments aren't going to be processable...
	selectors+=Selector (',' selectors+=Selector)*
	( '(' ( parameters+=Parameter (',' parameters+=Parameter )* )? ')' )?
	'{'
		firstMemberWrapper=ChainedRuleSetMemberWrapper?
	'}'
	;
	/*
	 * The RuleSetMember-s now hang off a maximally-unbalanced, right-sided parse/node tree.
	 * This weird construct is necessary to make the semi-colon a separating everything
	 * other than nested rule sets, rather than a delimiting token
	 * - in which case the final semi-colon would be required, rather than optional.
	 * (Having a semi-colon after a rule set is illegal.)
	 * ((Note that having a semi-colon after the last declaration in a CSS block
	 *   is technically illegal as well.))
	 * 
	 * Use LessLanguageHelper#members(ExtendedRuleSet) to obtain a linear list.
	 */

// re-def. of the rule from the CSS grammar, to incorporate the ParentCombinator
SimpleSelectorSequence hidden():
	  ( head=( TypeSelector | UniversalSelector ) simpleSelectors+=TailSimpleSelector* )
	| (                                           simpleSelectors+=TailSimpleSelector+ )
	;

TailSimpleSelector returns css::SimpleSelector:	// synthetic type to limit choice for parser, without need for validation
	IDSelector | AttributeSelector | ClassSelector | PseudoSelector | NegationSelector | ParentCombinator
	;

ParentCombinator returns css::SimpleSelector:
	{ParentCombinator} '&'
	;

Parameter:
	variable=VariableDeclaration (':' defaultValue=ValueExpression)?
	;

ChainedRuleSetMemberWrapper:
	  member=ExtendedRuleSet (next=ChainedRuleSetMemberWrapper)?
	| member=SemiColonSeparatedExtendedRuleSetMember (';' next=ChainedRuleSetMemberWrapper?)?
	;

RuleSetMember:	// convenience super type
	ExtendedRuleSet | SemiColonSeparatedExtendedRuleSetMember
	;

SemiColonSeparatedExtendedRuleSetMember:
	MixinCall | ExpressivePropertyDeclaration | VariableDefinition
	;

MixinCall:
	(group=[ExtendedRuleSet|HASH_ID] (childCombined?='>')?)? ruleSet=[ExtendedRuleSet|DOT_ID]
		// TODO  ...but we may want to extended this to RuleSet as well,
		//			if we consider regular rule sets in an imported .css file
		//			as mixin candidates as well
		( '(' arguments+=ValueExpression (',' arguments+=ValueExpression)* ')' )?
	;
	// scoping of .group: all ExtendedRuleSets which have a single ID-name
	// scoping of .ruleSet: all mixin candidates
	// TODO  verify that this is what less.js understands as well (incorporates a while-loop in the parser but only supports 1 level)

ExpressivePropertyDeclaration:
	KnownPropertyExpressiveDeclaration | UnrecognizedPropertyExpressiveDeclaration
	;

KnownPropertyExpressiveDeclaration:
	name=KnownProperties ':' valuesLists=PropertyExpressionsLists
	;

UnrecognizedPropertyExpressiveDeclaration:
	name=PropertyName ':' valuesLists=PropertyExpressionsLists
	;

PropertyExpressionsLists:
	lists+=PropertyExpressionsList (',' lists+=PropertyExpressionsList)*
	;

PropertyExpressionsList:
	values+=PropertyExpression+
	;

PropertyExpression hidden(WS):
	value=ValueExpression important?='!important'?
	;


/*
 * +-------------------+
 * | Value expressions |
 * +-------------------+
 */

ValueExpression:
	AdditiveExpression
	;

AdditiveExpression returns ValueExpression:
	MultiplicativeExpression ({AdditiveExpression.left=current} operator=AdditiveOperators right=MultiplicativeExpression)*
	;

enum AdditiveOperators:
	plus='+' | minus='-'
	;

MultiplicativeExpression returns ValueExpression:
	PrimaryValueExpression ({MultiplicativeExpression.left=current} operator=MultiplicativeOperators right=PrimaryValueExpression)*
	;

enum MultiplicativeOperators:
	mult='*' | div='/'
	;
	// (note that a '%' modulo operator would cause non-LL(*) behavior in combination with the % dimension in (css::)NumberLiteral)

PrimaryValueExpression returns ValueExpression:
	  '(' ValueExpression ')'
	| ColorFunctionCall
	| VariableReference
	| {ArgumentsReference} '@arguments'
	| {CSSLiteral}			value=ValueLiteral
	| {EscapedLiteral}		value=EscapedValue
	| {JavascriptLiteral}	value=JAVASCRIPT_EVAL
	;

EscapedValue: '~' (STRING|JAVASCRIPT_EVAL) ;

ColorFunctionCall:
	  {TwoArgsFunctionCall} function=TwoArgsColorFunctions	'(' color=ValueExpression ',' modifier=NumberLiteral ')'
	| {OneArgFunctionCall}	function=OneArgColorFunctions	'(' color=ValueExpression ')'
	;
	// TODO  validation (requires evaluation engine)
	// TODO  consider incorporating IE's legacy "alpha(opacity=...)" function as well

enum TwoArgsColorFunctions:
	  lighten | darken
	| saturate | desaturate
	| fadein | fadeout
	| spin
	;

enum OneArgColorFunctions:
	hue | saturation | lightness
	;

VariableReference hidden():
	(indirections+='@')* variable=[VariableDeclaration|AT_ID]
	;
	// (.indirections counts the level of indirection)
	// validation:
	//   e.g., in @@var, the value of @var must be the (@-less) name of an existing variable
	// scoping:
	//   - mimic nesting of rule sets

// re-def. from CSS grammar to make it possible to use expressions:
ComponentColorLiteral:
	  {ComponentRGBColor}		'rgb'  '(' red=ValueExpression ',' green=ValueExpression ',' blue=ValueExpression ')'
	| {ComponentRGBAlphaColor}	'rgba' '(' red=ValueExpression ',' green=ValueExpression ',' blue=ValueExpression ',' opacity=ValueExpression ')'
	| {ComponentHSLColor}		'hsl'  '(' hue=ValueExpression ',' saturation=ValueExpression ',' lightness=ValueExpression ')'
	| {ComponentHSLAlphaColor}	'hsla' '(' hue=ValueExpression ',' saturation=ValueExpression ',' lightness=ValueExpression ',' opacity=ValueExpression ')'
	;
	// TODO  validation (requires evaluation engine)

// re-def. from CSS grammar to make ti possible to use expressions:
AlphaLiteral:
	'alpha' '(' 'opacity' '=' opacityExpr=ValueExpression ')'
	;
	// TODO  add validation (requires evaluation engine)
	// TODO  why can't we name the attribute 'opacity'? (it's possible for ComponentColorLiteral!)

// re-def. to exclude /-notation for line heights in font sizes:
NumberLiteral hidden():
	( {IntegerLiteral} int=INT | {DecimalLiteral} decimal=DECIMAL )
	dimension=Dimensions?
	;


/*
 * +-----------+
 * | Terminals |
 * +-----------+
 */

terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal AT_ID: '@' PREFIXABLE_ID_START ID_PART* ;
	// LessValueConverterService#AT_ID takes care of removing the @

terminal JAVASCRIPT_EVAL: '`' -> '`' ;

/*
 * For now: interpolate STRINGs during generation but don't support the
 * syntax on a grammar level yet - which would require a custom lexer... (TODO)
 */

// TODO  validation on STRINGs to check whether interpolation syntax is correct
//			(appear in .value of css::StringLiteral and css::AttributeSelector)

