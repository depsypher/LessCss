grammar nl.dslmeinte.xtext.less.Less with nl.dslmeinte.xtext.css.CSS hidden(WS, SL_COMMENT)

import "http://www.dslmeinte.nl/xtext/css" as css

generate less "http://www.dslmeinte.nl/xtext/less"


LessFile:
	statements+=Statement*;

Statement:
	(VariableDefinition ';') | ExtendedRuleSet | VisibleComment | Import
	;

VariableDefinition:
	name=VariableDeclaration ':' value=ValueExpression
	;

VariableDeclaration:
	name=AT_ID
	;

VisibleComment:
	comment=ML_COMMENT
	;

Import:
	'@import' importURI=STRING
	;
	// TODO  tweak ImportUriGlobalScopeProvider to check on the importURI's extension and behave accordingly


/*
 * +-----------+
 * | Rule sets |
 * +-----------+
 */

ExtendedRuleSet:
	selectors+=Selector (',' selectors+=Selector)*
	( '(' ( parameters+=Parameter (',' parameters+=Parameter )* )? ')' )?
	'{'
		firstMemberWrapper=ChainedRuleSetMemberWrapper?
	'}'
	;
	/*
	 * The RuleSetMember-s now hang off a maximally-unbalanced, right-sided parse/node tree.
	 * This weird construct is necessary to make the semi-colon a separating everything
	 * other than nested rule sets, rather than a delimiting token
	 * - in which case the final semi-colon would be required, rather than optional.
	 * (Having a semi-colon after a rule set is illegal.)
	 * 
	 * Use LessLanguageHelper#members(ExtendedRuleSet) to obtain a linear list.
	 */

// re-def. of the rule from the CSS grammar, to incorporate the ParentCombinator
SimpleSelectorSequence hidden():
	  ( head=( TypeSelector | UniversalSelector ) simpleSelectors+=TailSimpleSelector* )
	| (                                           simpleSelectors+=TailSimpleSelector+ )
	;

TailSimpleSelector returns css::SimpleSelector:	// synthetic type to limit choice for parser, without need for validation
	IDSelector | AttributeSelector | ClassSelector | PseudoSelector | NegationSelector | ParentCombinator
	;

ParentCombinator returns css::SimpleSelector:
	{ParentCombinator} '&'
	;

Parameter:
	variable=VariableDeclaration (':' defaultValue=ValueExpression)?
	;

ChainedRuleSetMemberWrapper:
	  member=ExtendedRuleSet (next=ChainedRuleSetMemberWrapper)?
	| member=SemiColonSeparatedExtendedRuleSetMember (';' next=ChainedRuleSetMemberWrapper?)?
	;

RuleSetMember:	// convenience super type
	ExtendedRuleSet | SemiColonSeparatedExtendedRuleSetMember
	;

SemiColonSeparatedExtendedRuleSetMember:
	MixinCall | PropertyExpression | VariableDefinition
	;

MixinCall:
	(group=[ExtendedRuleSet|HASH_ID] '>')? ruleSet=[ExtendedRuleSet|DOT_ID]
		// TODO  ...but we may want to extended this to RuleSet as well,
		//			if we consider regular rule sets in an imported .css file
		//			as mixin candidates as well
		( '(' arguments+=ValueExpression (',' arguments+=ValueExpression)* ')' )?
	;
	// scoping of .group: all ExtendedRuleSets which have a single ID-name
	// scoping of .ruleSet: all mixin candidates

PropertyExpression:
	KnownPropertyExpression | UnknownPropertyExpression
	;

KnownPropertyExpression:
	name=KnownProperties ':' values+=ValueExpression+
	;

UnknownPropertyExpression:
	name=ID ':' values+=ValueExpression+
	;


/*
 * +-------------------+
 * | Value expressions |
 * +-------------------+
 */

ValueExpression:
	AdditiveExpression
	;

AdditiveExpression returns ValueExpression:
	MultiplicativeExpression ({AdditiveExpression.left=current} operator=AdditiveOperators right=MultiplicativeExpression)*
	;

enum AdditiveOperators:
	plus='+' | minus='-'
	;

MultiplicativeExpression returns ValueExpression:
	PrimaryValueExpression ({MultiplicativeExpression.left=current} operator=MultiplicativeOperators right=PrimaryValueExpression)*
	;

enum MultiplicativeOperators:
	mult='*' | div='/'
	;
	// (note that a '%' modulo operator would cause non-LL(*) behavior in combination with the % dimension in (css::)NumberLiteral)

PrimaryValueExpression returns ValueExpression:
	  '(' ValueExpression ')'
	| ColorFunctionCall
	| VariableReference
	| {ArgumentsReference} '@arguments'
	| {CSSLiteral}			value=ValueLiteral
	| {EscapedLiteral}		value=ESCAPED_VALUE
	| {JavascriptLiteral}	value=JAVASCRIPT_EVAL
	;

ColorFunctionCall:
	  {TwoArgsFunctionCall} function=TwoArgsColorFunctions	'(' color=ValueExpression ',' modifier=NumberLiteral ')'
	| {OneArgFunctionCall}	function=OneArgColorFunctions	'(' color=ValueExpression ')'
	;
	// TODO  validation (requires evaluation engine)

enum TwoArgsColorFunctions:
	  lighten | darken
	| saturate | desaturate
	| fadein | fadeout
	| spin
	;

enum OneArgColorFunctions:
	hue | saturation | lightness
	;

VariableReference hidden():
	(indirections+='@')* variable=[VariableDeclaration|AT_ID]
	;
	// (.indirections counts the level of indirection)
	// validation:
	//   e.g., in @@var, the value of @var must be the (@-less) name of an existing variable
	// scoping:
	//   - mimic nesting of rule sets

// re-def. from CSS grammar to make it possible to use expressions:
ComponentColorLiteral:
	  {ComponentRGBColor} 'rgb' '(' red=ValueExpression ',' green=ValueExpression ',' blue=ValueExpression ')'
	| {ComponentHSLColor} 'hsl' '(' hue=ValueExpression ',' saturation=ValueExpression ',' lightness=ValueExpression ')'
	;
	// TODO  validation (requires evaluation engine)


/*
 * +-----------+
 * | Terminals |
 * +-----------+
 */

terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal AT_ID: '@' PREFIXABLE_ID_START ID_PART* ;
	// LessValueConverterService#AT_ID takes care of removing the @

terminal ESCAPED_VALUE: '~' -> ( ';' | '}' ) ;

terminal JAVASCRIPT_EVAL: '`' -> '`' ;

/*
 * For now: interpolate STRINGs during generation but don't support the
 * syntax on a grammar level yet - which would require a custom lexer... (TODO)
 */

// TODO  validation on STRINGs to check whether interpolation syntax is correct
//			(appear in .value of css::StringLiteral and css::AttributeSelector)

